#include <iostream>
#include <math.h>
#include <stdio.h>
#include "BlockTri2.h"

#ifndef M_PI
#define M_PI 3.141592653
#endif

int
main()
{
	const int n_eqn = 20;
	BlockTriMatrix2 M(n_eqn);
	BlockTriVector2 x(n_eqn), y(n_eqn), y_before(n_eqn), z(n_eqn);

	Matrix2 LL, L, D;

	for (int i = 0; i < n_eqn; i++) {

		i++;

#define TEST
#ifdef TEST
		LL(0,0) = 0.001;
		LL(1,0) = 0.001;
		LL(0,1) = -0.001;
		LL(1,1) = 0.001;
#else
		LL(0,0) = i-1;
		LL(1,0) = -1;
		LL(0,1) = i+1;
		LL(1,1) = i;
#endif

		L(0,0) = 1./(i+2);
		L(1,0) = 1./(i+1);
		L(0,1) = 1./i;
		L(1,1) = -1./(i+1);

		D(0,0) = -10.;
		D(1,0) = 1.;
		D(0,1) = 1.;
		D(1,1) = 10.;

		i--;

		M.lower_lower_diagonal()(i) = LL;
		M.lower_diagonal()(i) = L;
		M.diagonal()(i) = D;
		y(i)(0) = i;
		y(i)(1) = i+1;
	}

	y_before = y;
	cerr << "M before:\n";
	cerr << "lower_lower:\n" << M.lower_lower_diagonal();
	cerr << "lower:\n" << M.lower_diagonal();
	cerr << "diag:\n" << M.diagonal();
	cerr << "y before:\n" << y_before;

	solve_lower(M, x, y);

	// Compute z = M*x, which should equal y.
	z(0) = M.diagonal()(0)*x(0);
	z(1) = M.lower_diagonal()(0)*x(0) + M.diagonal()(1)*x(1);
	for (int i = 2; i < n_eqn; i++)
		z(i) = M.lower_lower_diagonal()(i-1)*x(i-2)
			+ M.lower_diagonal()(i-1)*x(i-1)
			+ M.diagonal()(i)*x(i);

	cerr << "M after:\n";
	cerr << "lower_lower:\n" << M.lower_lower_diagonal();
	cerr << "lower:\n" << M.lower_diagonal();
	cerr << "diag:\n" << M.diagonal();
	cerr << "y after:\n" << y;

	cerr << "x:\n" << x;
	cerr << "M*x:\n" << z;
	cerr << "M*x - y_before:\n" << z - y_before;

	return 0;
}
